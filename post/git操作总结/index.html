<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>git学习 | java学习</title><meta name=keywords content="git,svn"><meta name=description content="由于之前使用svn,最近改用git,虽然也用过一段时间git,但这前大部分时候都是在单人使用github,因此在这里好好学习一下git的相关操作,并对git的操作进行总结.
1.git和svn的区别 之前用过svn的可以参考此段.
区别 此表格出处
    Git(分布式版本控制系统) Svn(集中式版本控制系统)     工作流程 1.写代码2.提交到本地版本库3.从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突4.将远程库与本地代码合并结果提交到本地版本库5.将本地版本库推到服务器 1.写代码2.从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突3.将本地代码提交到服务器   是否有中央服务器 没有中央服务器，开发人员本地都有 Local Repository 有。开发人员需要从中央服务器获得最新版本的项目然后在本地开发，开发完推送给中央服务器。因此脱离服务器开发者是几乎无法工作的   **网络依赖 ** 分布式在没有网络的情况下也可以执行commit、查看版本提交记录、以及分支操作，在有网络的情况下执行 push 到 Remote Repository。 必须要联网才能工作，而且对网络的依赖性较强，如果推送的文件比较大而且网络状况欠佳，则提交文件的速度会受到很大的限制。   分支操作影响 分支操作不会影响其他开发人员 创建新的分支则所有的人都会拥有和你一样的分支   提交过程 提交是本地操作，需要执行push操作才会到主要版本库 提交的文件会直接记录到中央版本库    理解 在表格中我们看到Git是分布式版本控制系统,而svn是集中式,我们可能会奇怪,svn我们也是多人在不同的电脑上协作啊,但是理解了两者的区别,我们就会发现,svn只有一个中央库,存放在中央服务器中,而git有多个仓库,我们每个人都有自己的个人仓库,也可以创建多个分支.
我们可以这样理解:svn有一个中央库,我们的一切操作都要和svn的中央库挂钩,当我们没有网络了,我们无法提交,也无法查看日志,我们做的一切都服务于svn中央库,而git我们每个人都有自己的库,即使没有网络,我们也可以提交,可以回滚,可以查看日志,当我们想和远程库进行操作的时候,只需要push即可,远程库相当于一个媒介,帮助我们和别人进行沟通交流,但没有远程库,我们自己也可以使用git进行版本控制
svn和git的操作也有不同:
  svn 我们想提交的时候,add 新文件(此步骤可以放在后面的解决冲突处执行),然后需要pull最新代码,然后本地解决冲突,然后commit
  git 我们提交的时候,add(和svn不同,新文件和修改的文件都需要add操作),然后commit,然后
  然后pull,然后解决冲突,最后push
svn每一次提交都要解决冲突,而git只有我们push的时候或者合并分支的时候才需要解决冲突(单一分支操作),对于git我们可以将一个功能的每一次修改都commit一次而无需解决冲突,直到整个功能开发完成,我们再进行最终的push,这里面深层次的原因就是svn的提交是和服务器交互,而git的提交时本地的i行为,push才是和服务器交互
2.git的分区    新增文件不在四个区当中 add&mdash;>暂存区     工作区 add&mdash;>暂存区   暂存区 commit&ndash;>本地仓库   本地仓库 push&mdash;>远程仓库   远程仓库     3."><meta name=author content="Zhang"><link rel=canonical href=https://1935868896.github.io/post/git%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.0e4a1b49e740c28140e9ee4945aab2f86cb0a7bfbf5a5d612d0cb5df7d6141f4.css integrity="sha256-DkobSedAwoFA6e5JRaqy+Gywp7+/Wl1hLQy1331hQfQ=" rel="preload stylesheet" as=style><link rel=icon href=https://1935868896.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://1935868896.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://1935868896.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://1935868896.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://1935868896.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.76.5"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-123-45','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="git学习"><meta property="og:description" content="由于之前使用svn,最近改用git,虽然也用过一段时间git,但这前大部分时候都是在单人使用github,因此在这里好好学习一下git的相关操作,并对git的操作进行总结.
1.git和svn的区别 之前用过svn的可以参考此段.
区别 此表格出处
    Git(分布式版本控制系统) Svn(集中式版本控制系统)     工作流程 1.写代码2.提交到本地版本库3.从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突4.将远程库与本地代码合并结果提交到本地版本库5.将本地版本库推到服务器 1.写代码2.从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突3.将本地代码提交到服务器   是否有中央服务器 没有中央服务器，开发人员本地都有 Local Repository 有。开发人员需要从中央服务器获得最新版本的项目然后在本地开发，开发完推送给中央服务器。因此脱离服务器开发者是几乎无法工作的   **网络依赖 ** 分布式在没有网络的情况下也可以执行commit、查看版本提交记录、以及分支操作，在有网络的情况下执行 push 到 Remote Repository。 必须要联网才能工作，而且对网络的依赖性较强，如果推送的文件比较大而且网络状况欠佳，则提交文件的速度会受到很大的限制。   分支操作影响 分支操作不会影响其他开发人员 创建新的分支则所有的人都会拥有和你一样的分支   提交过程 提交是本地操作，需要执行push操作才会到主要版本库 提交的文件会直接记录到中央版本库    理解 在表格中我们看到Git是分布式版本控制系统,而svn是集中式,我们可能会奇怪,svn我们也是多人在不同的电脑上协作啊,但是理解了两者的区别,我们就会发现,svn只有一个中央库,存放在中央服务器中,而git有多个仓库,我们每个人都有自己的个人仓库,也可以创建多个分支.
我们可以这样理解:svn有一个中央库,我们的一切操作都要和svn的中央库挂钩,当我们没有网络了,我们无法提交,也无法查看日志,我们做的一切都服务于svn中央库,而git我们每个人都有自己的库,即使没有网络,我们也可以提交,可以回滚,可以查看日志,当我们想和远程库进行操作的时候,只需要push即可,远程库相当于一个媒介,帮助我们和别人进行沟通交流,但没有远程库,我们自己也可以使用git进行版本控制
svn和git的操作也有不同:
  svn 我们想提交的时候,add 新文件(此步骤可以放在后面的解决冲突处执行),然后需要pull最新代码,然后本地解决冲突,然后commit
  git 我们提交的时候,add(和svn不同,新文件和修改的文件都需要add操作),然后commit,然后
  然后pull,然后解决冲突,最后push
svn每一次提交都要解决冲突,而git只有我们push的时候或者合并分支的时候才需要解决冲突(单一分支操作),对于git我们可以将一个功能的每一次修改都commit一次而无需解决冲突,直到整个功能开发完成,我们再进行最终的push,这里面深层次的原因就是svn的提交是和服务器交互,而git的提交时本地的i行为,push才是和服务器交互
2.git的分区    新增文件不在四个区当中 add&mdash;>暂存区     工作区 add&mdash;>暂存区   暂存区 commit&ndash;>本地仓库   本地仓库 push&mdash;>远程仓库   远程仓库     3."><meta property="og:type" content="article"><meta property="og:url" content="https://1935868896.github.io/post/git%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"><meta property="og:image" content="https://1935868896.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:published_time" content="2021-03-09T11:30:03+00:00"><meta property="article:modified_time" content="2021-03-09T11:30:03+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://1935868896.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="git学习"><meta name=twitter:description content="由于之前使用svn,最近改用git,虽然也用过一段时间git,但这前大部分时候都是在单人使用github,因此在这里好好学习一下git的相关操作,并对git的操作进行总结.
1.git和svn的区别 之前用过svn的可以参考此段.
区别 此表格出处
    Git(分布式版本控制系统) Svn(集中式版本控制系统)     工作流程 1.写代码2.提交到本地版本库3.从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突4.将远程库与本地代码合并结果提交到本地版本库5.将本地版本库推到服务器 1.写代码2.从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突3.将本地代码提交到服务器   是否有中央服务器 没有中央服务器，开发人员本地都有 Local Repository 有。开发人员需要从中央服务器获得最新版本的项目然后在本地开发，开发完推送给中央服务器。因此脱离服务器开发者是几乎无法工作的   **网络依赖 ** 分布式在没有网络的情况下也可以执行commit、查看版本提交记录、以及分支操作，在有网络的情况下执行 push 到 Remote Repository。 必须要联网才能工作，而且对网络的依赖性较强，如果推送的文件比较大而且网络状况欠佳，则提交文件的速度会受到很大的限制。   分支操作影响 分支操作不会影响其他开发人员 创建新的分支则所有的人都会拥有和你一样的分支   提交过程 提交是本地操作，需要执行push操作才会到主要版本库 提交的文件会直接记录到中央版本库    理解 在表格中我们看到Git是分布式版本控制系统,而svn是集中式,我们可能会奇怪,svn我们也是多人在不同的电脑上协作啊,但是理解了两者的区别,我们就会发现,svn只有一个中央库,存放在中央服务器中,而git有多个仓库,我们每个人都有自己的个人仓库,也可以创建多个分支.
我们可以这样理解:svn有一个中央库,我们的一切操作都要和svn的中央库挂钩,当我们没有网络了,我们无法提交,也无法查看日志,我们做的一切都服务于svn中央库,而git我们每个人都有自己的库,即使没有网络,我们也可以提交,可以回滚,可以查看日志,当我们想和远程库进行操作的时候,只需要push即可,远程库相当于一个媒介,帮助我们和别人进行沟通交流,但没有远程库,我们自己也可以使用git进行版本控制
svn和git的操作也有不同:
  svn 我们想提交的时候,add 新文件(此步骤可以放在后面的解决冲突处执行),然后需要pull最新代码,然后本地解决冲突,然后commit
  git 我们提交的时候,add(和svn不同,新文件和修改的文件都需要add操作),然后commit,然后
  然后pull,然后解决冲突,最后push
svn每一次提交都要解决冲突,而git只有我们push的时候或者合并分支的时候才需要解决冲突(单一分支操作),对于git我们可以将一个功能的每一次修改都commit一次而无需解决冲突,直到整个功能开发完成,我们再进行最终的push,这里面深层次的原因就是svn的提交是和服务器交互,而git的提交时本地的i行为,push才是和服务器交互
2.git的分区    新增文件不在四个区当中 add&mdash;>暂存区     工作区 add&mdash;>暂存区   暂存区 commit&ndash;>本地仓库   本地仓库 push&mdash;>远程仓库   远程仓库     3."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://1935868896.github.io/post/"},{"@type":"ListItem","position":2,"name":"git学习","item":"https://1935868896.github.io/post/git%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"git学习","name":"git学习","description":"由于之前使用svn,最近改用git,虽然也用过一段时间git,但这前大部分时候都是在单人使用github,因此在这里好好学习一下git的相关操作,并对git的操作进行总结.\n1.git和svn的区别 之前用过svn的可以参考此段.\n区别 此表格出处\n    Git(分布式版本控制系统) Svn(集中式版本控制系统)     工作流程 1.写代码2.提交到本地 …","keywords":["git","svn"],"articleBody":"由于之前使用svn,最近改用git,虽然也用过一段时间git,但这前大部分时候都是在单人使用github,因此在这里好好学习一下git的相关操作,并对git的操作进行总结.\n1.git和svn的区别 之前用过svn的可以参考此段.\n区别 此表格出处\n    Git(分布式版本控制系统) Svn(集中式版本控制系统)     工作流程 1.写代码2.提交到本地版本库3.从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突4.将远程库与本地代码合并结果提交到本地版本库5.将本地版本库推到服务器 1.写代码2.从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突3.将本地代码提交到服务器   是否有中央服务器 没有中央服务器，开发人员本地都有 Local Repository 有。开发人员需要从中央服务器获得最新版本的项目然后在本地开发，开发完推送给中央服务器。因此脱离服务器开发者是几乎无法工作的   **网络依赖 ** 分布式在没有网络的情况下也可以执行commit、查看版本提交记录、以及分支操作，在有网络的情况下执行 push 到 Remote Repository。 必须要联网才能工作，而且对网络的依赖性较强，如果推送的文件比较大而且网络状况欠佳，则提交文件的速度会受到很大的限制。   分支操作影响 分支操作不会影响其他开发人员 创建新的分支则所有的人都会拥有和你一样的分支   提交过程 提交是本地操作，需要执行push操作才会到主要版本库 提交的文件会直接记录到中央版本库    理解 在表格中我们看到Git是分布式版本控制系统,而svn是集中式,我们可能会奇怪,svn我们也是多人在不同的电脑上协作啊,但是理解了两者的区别,我们就会发现,svn只有一个中央库,存放在中央服务器中,而git有多个仓库,我们每个人都有自己的个人仓库,也可以创建多个分支.\n我们可以这样理解:svn有一个中央库,我们的一切操作都要和svn的中央库挂钩,当我们没有网络了,我们无法提交,也无法查看日志,我们做的一切都服务于svn中央库,而git我们每个人都有自己的库,即使没有网络,我们也可以提交,可以回滚,可以查看日志,当我们想和远程库进行操作的时候,只需要push即可,远程库相当于一个媒介,帮助我们和别人进行沟通交流,但没有远程库,我们自己也可以使用git进行版本控制\nsvn和git的操作也有不同:\n  svn 我们想提交的时候,add 新文件(此步骤可以放在后面的解决冲突处执行),然后需要pull最新代码,然后本地解决冲突,然后commit\n  git 我们提交的时候,add(和svn不同,新文件和修改的文件都需要add操作),然后commit,然后\n  然后pull,然后解决冲突,最后push\nsvn每一次提交都要解决冲突,而git只有我们push的时候或者合并分支的时候才需要解决冲突(单一分支操作),对于git我们可以将一个功能的每一次修改都commit一次而无需解决冲突,直到整个功能开发完成,我们再进行最终的push,这里面深层次的原因就是svn的提交是和服务器交互,而git的提交时本地的i行为,push才是和服务器交互\n2.git的分区    新增文件不在四个区当中 add—暂存区     工作区 add—暂存区   暂存区 commit–本地仓库   本地仓库 push—远程仓库   远程仓库     3.git一个完整的操作 下面介绍一个git的完整的提交操作流程\n1.git add . //(.或者根据文件add) 此步骤的目的是为了将我们想要的文件添加到暂存区\r2.git commit -m commit的内容 //此处我们提交了一个版本,版本提交到本地的版本库中\r3.git stash //比如说我们同时开发两个功能,现在我们另一个功能还没做完,只想提交一个功能,怎么办?使用git stash命令,将未提交的代码或者不想提交暂时存放起来(注意:这些代码不在暂存区),此时工作区的代码和暂存区的代码都会被隐藏起来(注:新增的文件也想隐藏需要使用git stash -u)\r4.git pull 5.解决冲突,此时如果产生冲突需要我们再提交一份解决冲突的版本\r6.git push //此时推送远端成功,push的是 提交版本+解决冲突版本\r7.git stash pop //将刚刚隐藏的提交的文件恢复出来\r8.继续解决冲突 9.开始我们的工作\r4.git操作–对应命令 此处以操作介绍命令,而第5章节将单独介绍命令,4,5章节可能会包含重复内容\n1.git 拉取线上的仓库 git clone 远程库地址\r2.git如何和线上的仓库关联 1.git remote add origin 远程仓库地址 //和线上仓库地址做关联 2.git pull 或者 git remote update origin --prune // 这一步仅仅是为了获得远程仓库的分支,很多方法\r3.git branch --set-upstream-to=origin/main(此处main填写远程的分支名) //将远程分支和本地当前分支绑定起来\r4.git pull/push git remote update origin --prune //刷新远程仓库的分支,如果远程仓库新建分支, 需要使用这条指令\rgit remote rm origin //此步骤是为了解除远程仓库的联系 git remote -v //查看远程仓库的地址\rgit branch -a //查看项目的分支, -a代表全部,包括了本地和远程\r此图为和线上仓库关联起来,最后的两条指令表示我们连接了远程仓库,但是并没有获得远程分支\n此图为 git pull指令的结果,之所以实行这一步是为了查到线上有几个分支,当然还有其他的办法\n3.git 提交单次文件 1.修改文件\r2.git add . //此处提交文件到暂存区,可以提交多个,也可以提交一个\r3.git commit -m 此处添加更新的备注 //此处提交文件到本地仓库\r4.git push //此处提交文件到远程仓库\rgit提交需要注意\n  git新增文件的操作和git修改文件的操作相同,没有任何多余的其他步骤\n  git提交的时候只会提交暂存区的文件\n  附1: git add\n在使用svn的时候,我们使用新增文件的时候 需要先add文件后提交,而更新的文件只需要commit即可 而在git当中,新增的文件git也默认添加了,但是新增和修改的文件都需要 add 添加到暂存区这一步骤\n附2: Untracked files:\ngit untracked files 实际上就是新增的文件,当我们使用add的时候,它会直接提交到暂存区,此处一定要记住和svn新增文件的不同之处\n使用git status 和git status -s 我们可以看到git 文件的状态\n附3:git reset\ngit reset 可以将我们提交到暂存区的文件重新返回去\n4.git 多次提交文件 修改---add---commit\r修改---add---commit\rgit push //此时我们直接push两次commit,远端可以看到两次的日志\r5.git 拉取远端文件 本地有修改,有冲突 此时pull失败,有两种普遍的解决方法,当然commit和stash也可以结合使用:\n1.git stash git stash //此种stash只会暂存 修改和暂存区文件 不会暂存新增文件\rgit pull\rgit stash pop stash@{0} //取出不删除\r或者 git stash pop //取出并删除\r有时候有新增文件,但是stash只暂存暂时修改的文件怎么办? git stash -u 或者 先add,再stash\r2.git commit git commit -m 本地提交\rgit pull //此处进入 (main|MERGING),下面是两种解决冲突的方法\r1.git merge --abort (此种方法是返回到冲突之前的情况当中,就是咱们pull前的情况)\r2.修改文件 ,解决冲突\rgit add .\rgit commit -m 解决冲突\rgit push //这样会多提交一个解决冲突的版本\r6.git如何删除远程仓库的记录 初学的时候,经常会无意的将自己的一些重要信息上传到github上去,比如说最常见的数据库的地址和密码,如果被别人发现,很容易出现问题,即使我们提交一份新的代码,但是还是能从github上面的提交记录中看到我们曾经暴露的信息\n下面讲一下我们删除github上面的提交记录\n清除历史提交,只保留最新提交 参考网址:github怎样清除历史提交，保留最新提交\n1、git clone [URL] 克隆git仓库\rcd [仓库名] 进入git仓库\r2、git checkout --orphan new_branch 创建一个名为new_branch新的空的分支\r3、git add -A 添加所有文件到new_branch分支\rgit commit -am '提交信息' 对new_branch分支做一次提交\r4、git branch -D master 删除master分支\r5、git branch -m master 将当前所在的new_branch分支重命名为master\r6、git push origin master --force 将更改强制推送到github仓库\r回退版本 git log 查看提交的版本号 //查看准备回退的版本\rgit reset (--hard/--soft/不加参数(mixed) )版本号 //本地回退版本\rgit push --force //提交\r此种方法就是将我们的版本回退到提交敏感信息之前的那个版本,这样我们删除敏感信息,再次提交就可以了\r--hard 模式,回退指定版本号,同时清除我们本地的所有修改,清除指定版本号之后的所有修改\r--soft 模式,回退版本号,同时将本地的所有修改和版本号之后的所有修改全部退回到工作区/和未追踪(add+commit)\r--mixed模式,回退版本号,将版本号之后的所有修改回退到暂存区(可以直接commit)\r删除某一个版本 前面几种都或多或少有问题,下面这种方法是最好的办法,我们使用\n1.git rebase -i HEAD~2 //此种方法选择的是近三次提交\r2.git rebase -i commit版本号 //此种选择的是该版本之后的所有版本\r上面两种方式选择任一种,就会进入rebase--界面 类似于:\rpick 34699ae 提交1 最旧\rpick 37f6884 提交2 pick ca09187 提交3 最新\r此时,我们修改一下,修改成:\rpick 34699ae 提交1\rd 37f6884 提交2\rpick ca09187 提交3\r简单说我们抛弃哪个版本就在前面加上 d 即可\r保存之后,继续使用 git push --force即可\r因为我们要做的是删除提交记录,不再像push提交,即使提交错误,我们也可以通过回滚版本解决问题,因此做上面这些操作的时候一定要小心,可以使用新建分支做一下备份,这样操作失误依然有机会挽救\n5.git 命令介绍 git merge的详细介绍 git merge常用的三种模式,其中有两种经常被使用\ngit merge –ff 和 git merge –no-ff 这两种,首先在merge的时候两个分支都有提交时候是没有区别的,但是有一种情况出现:\n我们在A分支合并B分支的时候,A分支我们没有提交,但是B分支提交了,此时会出现差别,\n  –ff这种命令会直接移动指针,将B分支提交的东西,都归于A分支\n  –no-ff这种命令会保留B分支的提交记录,产生一个新的提交\n  当使用第一种方法的时候,提交记录是一条直线,使用第二种方法的时候会产生分支\n一般日常工作中,merge默认的是-ff这种,但是很多时候我们推荐使用 –no-ff,因为这种命令可以让我们清楚的看到记录哪个分支提交,另外此命令回退的时候,我们不会回退分支提交的记录(因为个人的分支可能会提交很多次),而是回退主分支的记录\ngit 分支操作 git branch dev1 //git创建分支\rgit checkout dev1 //git修改分支\rgit rebase的详细介绍 1.选择commit\n git rebase -i HEAD~2 后面的数字代表着最新的几个版本 git rebase -i commitId 表示该版本号(不包含本版本)之后提交的所有版本  进入编辑页面,我们将pick修改成我们想要的操作就好了,最常用的应该就是squash了  pick 34699ae 提交1\rpick 37f6884 提交2\rpick ca09187 提交3\r#######################################################################\rpick：保留该commit（缩写:p）\rreword：保留该commit，但我需要修改该commit的注释（缩写:r）\redit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）\rsquash：将该commit和前一个commit合并（缩写:s）\rfixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）\rexec：执行shell命令（缩写:x）\rdrop：我要丢弃该commit（缩写:d）\r3.编辑好之后,:wq进入编辑注释的页面编辑commit注释,或者进入解决冲突的界面解决冲突\ngit commit –amend的介绍 先看使用场景,比如说我们本次提交了aa.txt,bb.txt,突然发现还有cc.txt没提交,此时我们的办法是什么?\n 提交cc.txt,此时git版本库存在两条commit记录,但实际上干的是一回事 使用reset退回,然后再次提交  当然下面我们介绍另一种方法:\n1.将cc.txt提交到暂存区\r2.使用 git commit --amend //此方法类似于补丁,将暂存区的文件直接合并到最新一次提交\r3.当然上面可以编辑commit的注释,使用 git commit --amend --no-edit可以直接提交\rgit查看日志树–类似于idea的log表现形式 git log --oneline --graph --decorate --all\rgit reset的详细介绍 git reset [ –soft | –mixed | –hard] \rreset –hard reset–hard模式:将我们的代码回退当相应的版本,同时清空工作区,暂存区以及回退版本之后提交的所有代码,如果你有新的文件,但是没有提交到暂存区,依然存在(实际这代表着新文件没有被git控制)\nreset 不加参数(mixed) 简单一点理解,reset和reset –soft都意味者你的操作不会被清除,这里面包括 你修改的文件,你新增的文件,你add之后暂存的文件,以及你回退版本之后又提交上去的文件,两者的区别只是这些文件存放的位置\n–soft意味着你本次的操作不动,曾经提交的记录进入暂存区\n–mixed意味着你本次的提交到暂存区的文件和你曾经提交的进入暂存区的文件再次退一步,退回到工作区或者Untracked files\nreset –soft 将提交的文件退回到暂存区,此时只要我们再次commit就可以提交\n撤回暂存区的文件 当我们想要撤销暂存区的一个文件或者一批文件,该怎么操作?\n  git reset 撤销暂存区\n  git reset 文件名 从暂存区退回单个文件\n  看一下本质,实际上使用我们还是再使用 git reset指令,只是版本号默认成为了最新的版本号\n再试一下 git reset --hard 我们的工作区,暂存区文件都被清理了,而git reset --soft呢,git的状态没有发生任何改变\n总结 hard模式需要我们谨慎使用,简单来说hard模式会把我们 提交的,暂存区,工作区全部清空\nmixed,soft都会保留我们的工作信息,但是不同的是soft会将曾经提交的文件放到暂存区,mixed在此基础上清空暂存区\n","wordCount":"484","inLanguage":"en","datePublished":"2021-03-09T11:30:03Z","dateModified":"2021-03-09T11:30:03Z","author":{"@type":"Person","name":"Zhang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://1935868896.github.io/post/git%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"},"publisher":{"@type":"Organization","name":"java学习","logo":{"@type":"ImageObject","url":"https://1935868896.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://1935868896.github.io/ accesskey=h title="java学习博客 (Alt + H)">java学习博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://1935868896.github.io/archives/ title=archive><span>archive</span></a></li><li><a href=https://1935868896.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>git学习</h1><div class=post-meta>March 9, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Zhang</div></header><div class=post-content><p>由于之前使用svn,最近改用git,虽然也用过一段时间git,但这前大部分时候都是在单人使用github,因此在这里好好学习一下git的相关操作,并对git的操作进行总结.</p><h2 id=1git和svn的区别>1.git和svn的区别<a hidden class=anchor aria-hidden=true href=#1git和svn的区别>#</a></h2><p>之前用过svn的可以参考此段.</p><h3 id=区别>区别<a hidden class=anchor aria-hidden=true href=#区别>#</a></h3><p><a href=https://www.cnblogs.com/pawn-i/p/11898038.html>此表格出处</a></p><table><thead><tr><th></th><th>Git(分布式版本控制系统)</th><th>Svn(集中式版本控制系统)</th></tr></thead><tbody><tr><td><strong>工作流程</strong></td><td><img src=%E5%9B%BE%E5%BA%93/git-%E6%B5%81%E7%A8%8B.png alt=img> 1.写代码2.提交到本地版本库3.从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突4.将远程库与本地代码合并结果提交到本地版本库5.将本地版本库推到服务器</td><td><img src=%E5%9B%BE%E5%BA%93/svn-%E6%B5%81%E7%A8%8B.jpg alt=img>1.写代码2.从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突3.将本地代码提交到服务器</td></tr><tr><td><strong>是否有中央服务器</strong></td><td>没有中央服务器，开发人员本地都有 Local Repository</td><td>有。开发人员需要从中央服务器获得最新版本的项目然后在本地开发，开发完推送给中央服务器。因此脱离服务器开发者是几乎无法工作的</td></tr><tr><td>**网络依赖 **</td><td>分布式在没有网络的情况下也可以执行commit、查看版本提交记录、以及分支操作，在有网络的情况下执行 push 到 Remote Repository。</td><td>必须要联网才能工作，而且对网络的依赖性较强，如果推送的文件比较大而且网络状况欠佳，则提交文件的速度会受到很大的限制。</td></tr><tr><td><strong>分支操作影响</strong></td><td>分支操作不会影响其他开发人员</td><td>创建新的分支则所有的人都会拥有和你一样的分支</td></tr><tr><td><strong>提交过程</strong></td><td>提交是本地操作，需要执行push操作才会到主要版本库</td><td>提交的文件会直接记录到中央版本库</td></tr></tbody></table><h3 id=理解>理解<a hidden class=anchor aria-hidden=true href=#理解>#</a></h3><p>在表格中我们看到Git是分布式版本控制系统,而svn是集中式,我们可能会奇怪,svn我们也是多人在不同的电脑上协作啊,但是理解了两者的区别,我们就会发现,svn只有一个中央库,存放在中央服务器中,而git有多个仓库,我们每个人都有自己的个人仓库,也可以创建多个分支.</p><p>我们可以这样理解:svn有一个中央库,我们的一切操作都要和svn的中央库挂钩,当我们没有网络了,我们无法提交,也无法查看日志,我们做的一切都服务于svn中央库,而git我们每个人都有自己的库,即使没有网络,我们也可以提交,可以回滚,可以查看日志,当我们想和远程库进行操作的时候,只需要push即可,远程库相当于一个媒介,帮助我们和别人进行沟通交流,但没有远程库,我们自己也可以使用git进行版本控制</p><p>svn和git的操作也有不同:</p><ul><li><p>svn 我们想提交的时候,add 新文件(此步骤可以放在后面的解决冲突处执行),然后需要pull最新代码,然后本地解决冲突,然后commit</p></li><li><p>git 我们提交的时候,add(和svn不同,新文件和修改的文件都需要add操作),然后commit,然后</p></li></ul><p>然后pull,然后解决冲突,最后push</p><p>svn每一次提交都要解决冲突,而git只有我们push的时候或者合并分支的时候才需要解决冲突(单一分支操作),对于git我们可以将一个功能的每一次修改都commit一次而无需解决冲突,直到整个功能开发完成,我们再进行最终的push,这里面深层次的原因就是svn的提交是和服务器交互,而git的提交时本地的i行为,push才是和服务器交互</p><h2 id=2git的分区>2.git的分区<a hidden class=anchor aria-hidden=true href=#2git的分区>#</a></h2><p><img src=%E5%9B%BE%E5%BA%93%5Cgit071601.png alt></p><table><thead><tr><th>新增文件不在四个区当中</th><th>add&mdash;>暂存区</th></tr></thead><tbody><tr><td>工作区</td><td>add&mdash;>暂存区</td></tr><tr><td>暂存区</td><td>commit&ndash;>本地仓库</td></tr><tr><td>本地仓库</td><td>push&mdash;>远程仓库</td></tr><tr><td>远程仓库</td><td></td></tr></tbody></table><h2 id=3git一个完整的操作>3.git一个完整的操作<a hidden class=anchor aria-hidden=true href=#3git一个完整的操作>#</a></h2><p>下面介绍一个git的完整的提交操作流程</p><pre><code>1.git add .                //(.或者根据文件add) 此步骤的目的是为了将我们想要的文件添加到暂存区
2.git commit -m commit的内容   //此处我们提交了一个版本,版本提交到本地的版本库中
3.git stash                   //比如说我们同时开发两个功能,现在我们另一个功能还没做完,只想提交一个功能,怎么办?使用git stash命令,将未提交的代码或者不想提交暂时存放起来(注意:这些代码不在暂存区),此时工作区的代码和暂存区的代码都会被隐藏起来(注:新增的文件也想隐藏需要使用git stash -u)
4.git pull    
5.解决冲突,此时如果产生冲突需要我们再提交一份解决冲突的版本
6.git push                   //此时推送远端成功,push的是 提交版本+解决冲突版本
7.git stash pop              //将刚刚隐藏的提交的文件恢复出来
8.继续解决冲突      
9.开始我们的工作
</code></pre><h2 id=4git操作--对应命令>4.git操作&ndash;>对应命令<a hidden class=anchor aria-hidden=true href=#4git操作--对应命令>#</a></h2><p>此处以操作介绍命令,而第5章节将单独介绍命令,4,5章节可能会包含重复内容</p><h3 id=1git--拉取线上的仓库>1.git 拉取线上的仓库<a hidden class=anchor aria-hidden=true href=#1git--拉取线上的仓库>#</a></h3><pre><code class=language-git data-lang=git>git clone 远程库地址
</code></pre><h3 id=2git如何和线上的仓库关联>2.git如何和线上的仓库关联<a hidden class=anchor aria-hidden=true href=#2git如何和线上的仓库关联>#</a></h3><pre><code>1.git remote add origin 远程仓库地址  //和线上仓库地址做关联 
2.git pull 或者 git remote update origin --prune  // 这一步仅仅是为了获得远程仓库的分支,很多方法
3.git branch --set-upstream-to=origin/main(此处main填写远程的分支名)  //将远程分支和本地当前分支绑定起来
4.git pull/push                        

git remote update origin --prune //刷新远程仓库的分支,如果远程仓库新建分支, 需要使用这条指令
git remote rm origin           //此步骤是为了解除远程仓库的联系                       
git remote -v                  //查看远程仓库的地址
git branch -a                  //查看项目的分支, -a代表全部,包括了本地和远程
</code></pre><p>此图为和线上仓库关联起来,最后的两条指令表示我们连接了远程仓库,但是并没有获得远程分支</p><p><img src=%E5%9B%BE%E5%BA%93%5Cimage-20210302160056385.png alt=image-20210302160056385></p><p>此图为 git pull指令的结果,之所以实行这一步是为了查到线上有几个分支,当然还有其他的办法</p><p><img src=%E5%9B%BE%E5%BA%93%5Cimage-20210302154737564.png alt=image-20210302154737564></p><h3 id=3git-提交单次文件>3.git 提交单次文件<a hidden class=anchor aria-hidden=true href=#3git-提交单次文件>#</a></h3><pre><code>1.修改文件
2.git add .                                //此处提交文件到暂存区,可以提交多个,也可以提交一个
3.git commit -m 此处添加更新的备注            //此处提交文件到本地仓库
4.git push                                 //此处提交文件到远程仓库
</code></pre><p><strong>git提交需要注意</strong></p><ul><li><p><code>git新增文件的操作和git修改文件的操作相同</code>,没有任何多余的其他步骤</p></li><li><p><code>git提交的时候只会提交暂存区的文件</code></p></li></ul><p><strong>附1: git add</strong></p><p>在使用svn的时候,我们使用新增文件的时候 需要先add文件后提交,而更新的文件只需要commit即可
而在git当中,新增的文件git也默认添加了,但是新增和修改的文件都需要 add 添加到暂存区这一步骤</p><p><strong>附2: Untracked files:</strong></p><p>git untracked files 实际上就是新增的文件,当我们使用add的时候,它会直接提交到暂存区,此处一定要记住和svn新增文件的不同之处</p><p>使用git status 和git status -s 我们可以看到git 文件的状态</p><p><img src=./%E5%9B%BE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201224110834.png alt></p><p><strong>附3:git reset</strong></p><p>git reset 可以将我们提交到暂存区的文件重新返回去</p><h3 id=4git-多次提交文件>4.git 多次提交文件<a hidden class=anchor aria-hidden=true href=#4git-多次提交文件>#</a></h3><pre><code>修改---&gt;add---&gt;commit
修改---&gt;add---&gt;commit
git push                                      //此时我们直接push两次commit,远端可以看到两次的日志
</code></pre><h3 id=5git-拉取远端文件>5.git 拉取远端文件<a hidden class=anchor aria-hidden=true href=#5git-拉取远端文件>#</a></h3><h5 id=本地有修改有冲突>本地有修改,有冲突<a hidden class=anchor aria-hidden=true href=#本地有修改有冲突>#</a></h5><p>此时pull失败,有两种普遍的解决方法,当然commit和stash也可以结合使用:</p><h5 id=1git-stash>1.git stash<a hidden class=anchor aria-hidden=true href=#1git-stash>#</a></h5><pre><code>git stash       //此种stash只会暂存 修改和暂存区文件 不会暂存新增文件
git pull
git stash pop stash@{0}       //取出不删除
或者 git stash pop             //取出并删除
有时候有新增文件,但是stash只暂存暂时修改的文件怎么办? 
git stash -u  或者 先add,再stash
</code></pre><h5 id=2git-commit>2.git commit<a hidden class=anchor aria-hidden=true href=#2git-commit>#</a></h5><pre><code>git commit -m 本地提交
git pull              //此处进入 (main|MERGING),下面是两种解决冲突的方法

1.git merge --abort (此种方法是返回到冲突之前的情况当中,就是咱们pull前的情况)

2.修改文件 ,解决冲突
git add .
git commit -m 解决冲突
git push               //这样会多提交一个解决冲突的版本
</code></pre><h3 id=6git如何删除远程仓库的记录>6.git如何删除远程仓库的记录<a hidden class=anchor aria-hidden=true href=#6git如何删除远程仓库的记录>#</a></h3><p>初学的时候,经常会无意的将自己的一些重要信息上传到github上去,比如说最常见的数据库的地址和密码,如果被别人发现,很容易出现问题,即使我们提交一份新的代码,但是还是能从github上面的提交记录中看到我们曾经暴露的信息</p><p>下面讲一下我们删除github上面的提交记录</p><h5 id=清除历史提交只保留最新提交>清除历史提交,只保留最新提交<a hidden class=anchor aria-hidden=true href=#清除历史提交只保留最新提交>#</a></h5><p>参考网址:<a href=https://www.cnblogs.com/huangtianxing/p/9506187.html>github怎样清除历史提交，保留最新提交</a></p><pre><code>1、git clone [URL]                              克隆git仓库
      cd [仓库名]                                进入git仓库
2、git checkout --orphan  new_branch            创建一个名为new_branch新的空的分支
3、git add -A                                   添加所有文件到new_branch分支
   git commit -am '提交信息'                     对new_branch分支做一次提交
4、git branch -D master                         删除master分支
5、git branch -m master                         将当前所在的new_branch分支重命名为master
6、git push origin master --force               将更改强制推送到github仓库
</code></pre><h5 id=回退版本>回退版本<a hidden class=anchor aria-hidden=true href=#回退版本>#</a></h5><pre><code>git log  查看提交的版本号                  //查看准备回退的版本
git reset (--hard/--soft/不加参数(mixed) )版本号                  //本地回退版本
git push --force                         //提交

此种方法就是将我们的版本回退到提交敏感信息之前的那个版本,这样我们删除敏感信息,再次提交就可以了
--hard 模式,回退指定版本号,同时清除我们本地的所有修改,清除指定版本号之后的所有修改
--soft 模式,回退版本号,同时将本地的所有修改和版本号之后的所有修改全部退回到工作区/和未追踪(add+commit)
--mixed模式,回退版本号,将版本号之后的所有修改回退到暂存区(可以直接commit)
</code></pre><h5 id=删除某一个版本>删除某一个版本<a hidden class=anchor aria-hidden=true href=#删除某一个版本>#</a></h5><p>前面几种都或多或少有问题,下面这种方法是最好的办法,我们使用</p><pre><code>1.git rebase -i HEAD~2                                 //此种方法选择的是近三次提交
2.git rebase -i commit版本号                            //此种选择的是该版本之后的所有版本

上面两种方式选择任一种,就会进入rebase--界面 类似于:
pick 34699ae 提交1  最旧
pick 37f6884 提交2  
pick ca09187 提交3  最新

此时,我们修改一下,修改成:
pick 34699ae 提交1
d 37f6884 提交2
pick ca09187 提交3
简单说我们抛弃哪个版本就在前面加上 d 即可
保存之后,继续使用 git push --force即可
</code></pre><p>因为我们要做的是删除提交记录,不再像push提交,即使提交错误,我们也可以通过回滚版本解决问题,因此做上面这些操作的时候一定要小心,可以使用新建分支做一下备份,这样操作失误依然有机会挽救</p><h2 id=5git-命令介绍>5.git 命令介绍<a hidden class=anchor aria-hidden=true href=#5git-命令介绍>#</a></h2><h3 id=git-merge的详细介绍>git merge的详细介绍<a hidden class=anchor aria-hidden=true href=#git-merge的详细介绍>#</a></h3><p>git merge常用的三种模式,其中有两种经常被使用</p><h5 id=git-merge---ff-和-git-merge---no-ff>git merge &ndash;ff 和 git merge &ndash;no-ff<a hidden class=anchor aria-hidden=true href=#git-merge---ff-和-git-merge---no-ff>#</a></h5><p>这两种,首先在merge的时候两个分支都有提交时候是没有区别的,但是有一种情况出现:</p><p>我们在A分支合并B分支的时候,A分支我们没有提交,但是B分支提交了,此时会出现差别,</p><ul><li><p>&ndash;ff这种命令会直接移动指针,将B分支提交的东西,都归于A分支</p></li><li><p>&ndash;no-ff这种命令会保留B分支的提交记录,产生一个新的提交</p></li></ul><p>当使用第一种方法的时候,提交记录是一条直线,使用第二种方法的时候会产生分支</p><p>一般日常工作中,merge默认的是-ff这种,但是很多时候我们推荐使用 &ndash;no-ff,因为这种命令可以让我们清楚的看到记录哪个分支提交,另外此命令回退的时候,我们不会回退分支提交的记录(因为个人的分支可能会提交很多次),而是回退主分支的记录</p><h3 id=git-分支操作>git 分支操作<a hidden class=anchor aria-hidden=true href=#git-分支操作>#</a></h3><pre><code>git branch dev1         //git创建分支
git checkout dev1       //git修改分支
</code></pre><h3 id=git-rebase的详细介绍>git rebase的详细介绍<a hidden class=anchor aria-hidden=true href=#git-rebase的详细介绍>#</a></h3><p>1.选择commit</p><ul><li><code>git rebase -i HEAD~2</code> 后面的数字代表着最新的几个版本</li><li><code>git rebase -i commitId</code> 表示该版本号(不包含本版本)之后提交的所有版本</li></ul><ol start=2><li>进入编辑页面,我们将pick修改成我们想要的操作就好了,最常用的应该就是<code>squash</code>了</li></ol><pre><code>pick 34699ae 提交1
pick 37f6884 提交2
pick ca09187 提交3
#######################################################################
pick：保留该commit（缩写:p）
reword：保留该commit，但我需要修改该commit的注释（缩写:r）
edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）
squash：将该commit和前一个commit合并（缩写:s）
fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）
exec：执行shell命令（缩写:x）
drop：我要丢弃该commit（缩写:d）
</code></pre><p>3.编辑好之后,<code>:wq</code>进入编辑注释的页面编辑commit注释,或者进入解决冲突的界面解决冲突</p><h3 id=git-commit---amend的介绍>git commit &ndash;amend的介绍<a hidden class=anchor aria-hidden=true href=#git-commit---amend的介绍>#</a></h3><p>先看使用场景,比如说我们本次提交了aa.txt,bb.txt,突然发现还有cc.txt没提交,此时我们的办法是什么?</p><ul><li>提交cc.txt,此时git版本库存在两条commit记录,但实际上干的是一回事</li><li>使用reset退回,然后再次提交</li></ul><p>当然下面我们介绍另一种方法:</p><pre><code>1.将cc.txt提交到暂存区
2.使用 git commit --amend                    //此方法类似于补丁,将暂存区的文件直接合并到最新一次提交
3.当然上面可以编辑commit的注释,使用 git commit --amend --no-edit可以直接提交

</code></pre><h3 id=git查看日志树--类似于idea的log表现形式>git查看日志树&ndash;类似于idea的log表现形式<a hidden class=anchor aria-hidden=true href=#git查看日志树--类似于idea的log表现形式>#</a></h3><pre><code>git log --oneline --graph --decorate --all
</code></pre><h3 id=git-reset的详细介绍>git reset的详细介绍<a hidden class=anchor aria-hidden=true href=#git-reset的详细介绍>#</a></h3><pre><code>git reset [ –soft | –mixed | –hard] &lt;commit&gt;
</code></pre><h4 id=reset---hard>reset &ndash;hard<a hidden class=anchor aria-hidden=true href=#reset---hard>#</a></h4><p>reset&ndash;hard模式:将我们的代码回退当相应的版本,同时清空工作区,暂存区以及回退版本之后提交的所有代码,如果你有新的文件,但是没有提交到暂存区,依然存在(实际这代表着新文件没有被git控制)</p><h4 id=reset-不加参数mixed>reset 不加参数(mixed)<a hidden class=anchor aria-hidden=true href=#reset-不加参数mixed>#</a></h4><p>简单一点理解,reset和reset &ndash;soft都意味者你的操作不会被清除,这里面包括 你修改的文件,你新增的文件,你add之后暂存的文件,以及你回退版本之后又提交上去的文件,两者的区别只是这些文件存放的位置</p><p>&ndash;soft意味着你本次的操作不动,曾经提交的记录进入暂存区</p><p>&ndash;mixed意味着你本次的提交到暂存区的文件和你曾经提交的进入暂存区的文件再次退一步,退回到工作区或者Untracked files</p><h4 id=reset---soft>reset &ndash;soft<a hidden class=anchor aria-hidden=true href=#reset---soft>#</a></h4><p>将提交的文件退回到暂存区,此时只要我们再次commit就可以提交</p><h4 id=撤回暂存区的文件>撤回暂存区的文件<a hidden class=anchor aria-hidden=true href=#撤回暂存区的文件>#</a></h4><p>当我们想要撤销暂存区的一个文件或者一批文件,该怎么操作?</p><ul><li><p><code>git reset</code> 撤销暂存区</p></li><li><p><code>git reset 文件名</code> 从暂存区退回单个文件</p></li></ul><p>看一下本质,实际上使用我们还是再使用 git reset指令,只是版本号默认成为了最新的版本号</p><p>再试一下 <code>git reset --hard</code> 我们的工作区,暂存区文件都被清理了,而<code>git reset --soft</code>呢,git的状态没有发生任何改变</p><h4 id=总结><strong>总结</strong><a hidden class=anchor aria-hidden=true href=#总结>#</a></h4><p>hard模式需要我们谨慎使用,简单来说hard模式会把我们 提交的,暂存区,工作区全部清空</p><p>mixed,soft都会保留我们的工作信息,但是不同的是soft会将曾经提交的文件放到暂存区,mixed在此基础上清空暂存区</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://1935868896.github.io/tags/git/>git</a></li><li><a href=https://1935868896.github.io/tags/svn/>svn</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share git学习 on twitter" href="https://twitter.com/intent/tweet/?text=git%e5%ad%a6%e4%b9%a0&url=https%3a%2f%2f1935868896.github.io%2fpost%2fgit%25E6%2593%258D%25E4%25BD%259C%25E6%2580%25BB%25E7%25BB%2593%2f&hashtags=git%2csvn"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share git学习 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2f1935868896.github.io%2fpost%2fgit%25E6%2593%258D%25E4%25BD%259C%25E6%2580%25BB%25E7%25BB%2593%2f&title=git%e5%ad%a6%e4%b9%a0&summary=git%e5%ad%a6%e4%b9%a0&source=https%3a%2f%2f1935868896.github.io%2fpost%2fgit%25E6%2593%258D%25E4%25BD%259C%25E6%2580%25BB%25E7%25BB%2593%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share git学习 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f1935868896.github.io%2fpost%2fgit%25E6%2593%258D%25E4%25BD%259C%25E6%2580%25BB%25E7%25BB%2593%2f&title=git%e5%ad%a6%e4%b9%a0"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share git学习 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f1935868896.github.io%2fpost%2fgit%25E6%2593%258D%25E4%25BD%259C%25E6%2580%25BB%25E7%25BB%2593%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share git学习 on whatsapp" href="https://api.whatsapp.com/send?text=git%e5%ad%a6%e4%b9%a0%20-%20https%3a%2f%2f1935868896.github.io%2fpost%2fgit%25E6%2593%258D%25E4%25BD%259C%25E6%2580%25BB%25E7%25BB%2593%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share git学习 on telegram" href="https://telegram.me/share/url?text=git%e5%ad%a6%e4%b9%a0&url=https%3a%2f%2f1935868896.github.io%2fpost%2fgit%25E6%2593%258D%25E4%25BD%259C%25E6%2580%25BB%25E7%25BB%2593%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://1935868896.github.io/>java学习</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>